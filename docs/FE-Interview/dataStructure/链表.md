```js
// 链表定义
class Node {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

class NodeList {
  constructor(val) {
    this.head = new Node(val);
    this.length = 1;
  }

  // 上一个节点
  getPrevNode(targetVal) {
    let cur = this.head;
    while (cur.next) {
      if (cur.next.val === targetVal) {
        return cur;
      }
      cur = cur.next;
    }
    return null;
  }

  // 最后一个节点
  get lastNode() {
    let cur = this.head;
    while (cur.next) {
      cur = cur.next;
    }
    return cur;
  }

  // 尾插
  push(val) {
    this.lastNode.next = new Node(val);
    this.length++;
  }

  // 尾删
  pop() {
    let cur = this.head;
    while (cur.next.next) {
      cur = cur.next;
    }
    cur.next = null;
    this.length--;
  }

  // 头插
  unshift(val) {
    let newNode = new Node(val);
    newNode.next = this.head;
    this.head = newNode;
    this.length++;
  }

  // 头删
  shift() {
    let _next = this.head.next;
    this.head = _next;
    this.length--;
  }

  // 格式化输出
  printf() {
    let cur = this.head;
    let list = [];
    while (cur) {
      list.push(cur.val);
      cur = cur.next;
    }
    list.unshift("head");
    list.push("null");
    list = list.join(" ==> ");
    console.log(list);
    return list;
  }
}

// 常用套路
// 快慢指针寻找中间结点

// 反转链表
// https://leetcode-cn.com/problems/reverse-linked-list/   LeetCode 第 206 题
// 循环实现
function reverseList(head) {
  let [prev, curr] = [null, head];
  while (curr) {
    //  [curr.next, prev, curr] = [prev, curr, curr.next];
    let next = curr.next; // 1. 临时存储当前指针后续内容
    curr.next = prev; // 2. 反转链表
    prev = curr; // 3. 接收反转结果
    curr = next; // 4. 接回临时存储的后续内容
  }
  return prev;
}
// 递归实现
// https://leetcode-cn.com/problems/reverse-linked-list/solution/di-gui-jian-dan-li-jie-wu-xu-ceng-ceng-dai-ru-by-y/
function reverseList(head) {
  if (!head.next) return head; // 递归出口
  let res = reverseList(head.next);
  head.next.next = head;
  head.next = null;
  return res;
}

function reverseList(head) {
  const reverse = (prev, curr) => {
    if (!curr) return prev;
    let next = curr.next;
    curr.next = prev;
    return reverse(curr, next);
  };
  return reverse(null, head);
}

// 反转前 n 个结点的链表
function reverseN(head, n) {
  let connect = null; // 记录最后一个结点
  const reverse = (head, n) => {
    // 递归终止
    if (n === 1) {
      connect = head.next;
      return head;
    }
    let res = reverse(head.next, n - 1);
    head.next.next = head;
    head.next = connect; // 连接最后一个结点和反转之后的 head 结点
    return res;
  };
  return reverse(head, n);
}

// 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。
// https://leetcode-cn.com/problems/reverse-linked-list-ii/
function reverseBetween(head, m, n) {
  if (m == 1) {
    return reverseN(head, n);
  }
  head.next = reverseBetween(head.next, m - 1, n - 1);
  return head;
}

function reverseBetween(head, m, n) {
  if (m === n) return head; // 不反转
  let [prev, curr] = [null, head];
  for (let i = 1; i < m; i++) {
    prev = curr;
    curr = curr.next;
  }
  // front 为第一段的尾结点（为 null 表示 m = 1，即第一段不存在） tail 为交换列的第一个结点（交换后为最后一个）
  let [front, tail] = [prev, curr];
  for (let i = m; i <= n; i++) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  // curr 为第三段开始结点
  // prev 为第二段开始结点
  if (front) {
    // 存在第一段
    front.next = prev;
  } else {
    // 不存在第一段
    head = prev;
  }
  tail.next = curr;
  return head;
}

// 返回倒数第k个节点
// https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/
// 快慢指针
function kthToLast(head, k) {
  if (!head || !k) return head;
  let fast = head,
    slow = head;
  while (k) {
    k--;
    fast = fast.next;
  }
  while (fast) {
    slow = slow.next;
    fast = fast.next;
  }
  return slow;
}

// 合并两个有序链表
// https://leetcode-cn.com/problems/merge-two-sorted-lists/
function mergeTwoLists(l1, l2) {
  if (!l1) return l2;
  if (!l2) return l1;
  if (l1.val < l2.val) {
    l1.next = mergeTwoLists(l1.next, l2);
    return l1;
  } else {
    l2.next = mergeTwoLists(l1, l2.next);
    return l2;
  }
}

function mergeTwoLists(l1, l2) {
  let list = {},
    res = list;
  while (l1 && l2) {
    if (l1.val < l2.val) {
      list.next = l1;
      l1 = l1.next;
      list = list.next;
    } else {
      list.next = l2;
      l2 = l2.next;
      list = list.next;
    }
  }
  list.next = l1 ? l1 : l2;
  return res.next;
}

// 合并K个升序链表
// https://leetcode-cn.com/problems/merge-k-sorted-lists/
// 两两合并
function mergeKLists(lists) {
  if (lists.length === 0) return null;
  if (lists.length === 1) return lists[0];
  const mergeTwoLists = (l1, l2) => {
    if (!l1) return l2;
    if (!l2) return l1;
    if (l1.val < l2.val) {
      l1.next = mergeTwoLists(l1.next, l2);
      return l1;
    } else {
      l2.next = mergeTwoLists(l1, l2.next);
      return l2;
    }
  };
  let [left, right, i] = [lists[0], lists[1], 2];
  while (i <= lists.length) {
    left = mergeTwoLists(left, right);
    right = lists[i];
    i++;
  }
  return left;
}

// 归并
function mergeKLists(lists) {
  const mergeTwoLists = (l1, l2) => {
    if (!l1) return l2;
    if (!l2) return l1;
    if (l1.val < l2.val) {
      l1.next = mergeTwoLists(l1.next, l2);
      return l1;
    } else {
      l2.next = mergeTwoLists(l1, l2.next);
      return l2;
    }
  };
  const _mergeLists = (lists, start, end) => {
    if (end < start) return null;
    if (end === start) return lists[end];
    let mid = Math.floor(start + (end - start) / 2);
    return mergeTwoList(
      _mergeLists(lists, start, mid),
      _mergeLists(lists, mid + 1, end)
    );
  };
  return _mergeLists(lists, 0, lists.length - 1);
}

// 堆
function mergeKLists(lists) {
  let queue = new PriorityQueue();
  lists.forEach(list => {
    if (list) queue.enqueue(list, list.val);
  });

  let res = new ListNode(-1);
  let cur = res;
  while (!queue.isEmpty()) {
    cur.next = queue.dequeue();
    cur = cur.next;
    if (cur.next) queue.enqueue(cur.next, cur.next.val);
  }
  return res.next;
}

class Node {
  constructor(val, priority) {
    this.val = val;
    this.priority = priority;
  }
}

class PriorityQueue {
  constructor() {
    this.values = [];
  }

  enqueue(val, priority) {
    let node = new Node(val, priority);
    this.values.push(node);
    this.bubbleUp();
  }

  dequeue() {
    let max = this.values[0];
    let end = this.values.pop();
    if (this.values.length) {
      this.values[0] = end;
      this.bubbleDown();
    }
    return max.val;
  }

  isEmpty() {
    return !this.values.length;
  }

  bubbleUp(index = this.values.length - 1) {
    if (index <= 0) return;
    let parentIndex = Math.floor((index - 1) / 2);
    if (this.values[index].priority <= this.values[parentIndex].priority) {
      [this.values[index], this.values[parentIndex]] = [
        this.values[parentIndex],
        this.values[index],
      ];
      this.bubbleUp(parentIndex);
    }
  }

  bubbleDown(index = 0, swapIndex = null) {
    let leftIndex = index * 2 + 1,
      rightIndex = index * 2 + 2,
      length = this.values.length;

    if (leftIndex < length) {
      if (this.values[leftIndex].priority <= this.values[index].priority) {
        swapIndex = leftIndex;
      }
    }

    if (rightIndex < length) {
      if (
        (swapIndex === null &&
          this.values[rightIndex].priority <= this.values[index].priority) ||
        (swapIndex !== null &&
          this.values[rightIndex].priority <= this.values[leftIndex].priority)
      ) {
        swapIndex = rightIndex;
      }
    }

    if (swapIndex !== null) {
      [this.values[index], this.values[swapIndex]] = [
        this.values[swapIndex],
        this.values[index],
      ];
      this.bubbleDown(swapIndex, null);
    }
  }
}

// 旋转列表
// https://leetcode-cn.com/problems/rotate-list/
function rotateRight(head, k) {
  if (head == null) return null;
  if (head.next == null) return head;
  let [length, curr] = [1, head];
  while (curr.next) {
    length++;
    curr = curr.next;
  }
  curr.next = head;
  curr = head;
  for (let i = 0; i < length - (k % length) - 1; i++) {
    curr = curr.next;
  }
  let res = curr.next;
  curr.next = null;
  return res;
}

// 两数相加
// https://leetcode-cn.com/problems/add-two-numbers-ii/
function addTwoNumbers(l1, l2) {
  let stack1 = [],
    stack2 = [];
  while (l1) {
    stack1.push(l1.val);
    l1 = l1.next;
  }
  while (l2) {
    stack2.push(l2.val);
    l2 = l2.next;
  }
  let [mark, carry, curNode] = [0, null];
  while (stack1.length || stack2.length || mark) {
    let val1 = stack1.length ? stack1.pop() : 0;
    let val2 = stack2.length ? stack2.pop() : 0;
    let sum = val1 + val2 + mark;
    mark = (sum / 10) | 0;
    curNode = new ListNode(sum % 10);
    curNode.next = carry;
    carry = curNode;
  }
  return carry;
}

// 两两交换链表中的节点
// https://leetcode-cn.com/problems/swap-nodes-in-pairs/
function swapPairs(head) {
  if (!head || !head.next) return head;
  let [curr, next] = [head, head.next];
  curr.next = swapPairs(next.next);
  next.next = curr;
  return next;
}

function swapPairs(head) {
  if (!head || !head.next) return head;
  let curr,
    next,
    tmp = { next: head };
  const res = head.next;
  while ((curr = tmp.next) && (next = tmp.next.next)) {
    curr.next = next.next;
    next.next = curr;
    tmp.next = next;
    tmp = curr;
  }
  return res;
}

//  K 个一组翻转链表
// https://leetcode-cn.com/problems/reverse-nodes-in-k-group/
function reverseKGroup(head, k) {
  if (head == null) return null;
  const reverseKGroupHelper = (start, end) => {
    let [prev, curr] = [null, start];
    while (curr !== end) {
      let next = curr.next;
      curr.next = prev;
      prev = curr;
      curr = next;
    }
    return prev;
  };
  // 区间 [start, end] 包含 k 个待反转元素
  let [start, end] = [head, head];
  for (let i = 0; i < k; i++) {
    // 不足 k 个，不需要反转，base case
    if (end == null) return head;
    end = end.next;
  }
  // 反转前 k 个元素
  let newHead = reverseKGroupHelper(start, end);
  // 递归反转后续链表并连接起来
  start.next = reverseKGroup(end, k);
  return newHead;
}

// 判断一个链表是否为回文链表
// https://leetcode-cn.com/problems/palindrome-linked-list/
function isPalindrome(head) {
  if (!head || !head.next) return true; // 只有 0 个或者 1 个结点
  if (!head.next.next) return head.val === head.next.val; // 只有 2 个结点
  let [slow, fast] = [head, head]; // 快慢指针
  while (fast && fast.next) {
    slow = slow.next; // 慢指针一次一步
    fast = fast.next.next; // 快指针一次两步
  }
  if (fast) slow = slow.next; // 奇数
  let [prev, curr] = [null, slow]; // 反转后半部分链表
  while (curr) {
    let next = curr.next;
    curr.next = prev;
    prev = curr;
    curr = next;
  }
  while (prev) {
    if (prev.val !== head.val) {
      return false;
    }
    prev = prev.next;
    head = head.next;
  }
  return true;
}

// 给定一个链表，判断链表中是否有环。
// https://leetcode-cn.com/problems/linked-list-cycle/
function hasCycle(head) {
  const map = new Map();
  while (head) {
    if (map.get(head)) {
      return true;
    }
    map.set(head, head.val);
    head = head.next;
  }
  return false;
}

function hasCycle(head) {
  if (!head || !head.next) return false;
  let [slow, fast] = [head, head.next];
  while (fast && fast.next) {
    if (fast === slow) return true;
    slow = slow.next;
    fast = fast.next.next;
  }
  return false;
}

// 环形链表 II
// https://leetcode-cn.com/problems/linked-list-cycle-ii/
function detectCycle(head) {
  if (!head || !head.next) return null;
  let tmp = [];
  while (head) {
    if (tmp.includes(head)) return head;
    tmp.push(head);
    head = head.next;
  }
  return null;
}

function detectCycle(head) {
  if (!head || !head.next) return null;
  let [slow, fast] = [head, head];
  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;
    if (slow === fast) break;
  }
  if (!fast || !fast.next) return null;
  slow = head;
  while (true) {
    if (slow === fast) break;
    slow = slow.next;
    fast = fast.next;
  }
  return slow;
}

// 对链表进行插入排序
// https://leetcode-cn.com/problems/insertion-sort-list/
function insertionSortList(head) {
  if (!head || !head.next) return head;
  let [dummyHead, sortTail] = [{ next: head }, head]; // dummyHead 为头结点前的虚拟结点，sortTail 为已经排序链表的尾结点
  while (sortTail && sortTail.next) {
    // 寻找需要移动的结点
    if (sortTail.val <= sortTail.next.val) {
      sortTail = sortTail.next;
      continue;
    }
    let [prev, target] = [dummyHead, sortTail.next]; // prev 为插入位置的前一个结点，target 为需要移动的目标结点
    // 寻找插入位置
    while (prev.next.val < sortTail.next.val) {
      prev = prev.next;
    }
    // 找到了插入位置，进行结点插入
    sortTail.next = target.next;
    target.next = prev.next;
    prev.next = target;
  }
  return dummyHead.next;
}

// 在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。
// https://leetcode-cn.com/problems/sort-list/
// 归并排序（自顶向下-递归）
function sortList(head) {
  if (!head || !head.next) return head;
  const mergeTwoLists = (l1, l2) => {
    if (!l1) return l2;
    if (!l2) return l1;
    if (l1.val < l2.val) {
      l1.next = mergeTwoLists(l1.next, l2);
      return l1;
    } else {
      l2.next = mergeTwoLists(l1, l2.next);
      return l2;
    }
  };
  let [slow, fast, prev] = [head, head];
  while (fast && fast.next) {
    prev = slow;
    slow = slow.next;
    fast = fast.next.next;
  }
  prev.next = null;
  return mergeTwoLists(sortList(head), sortList(slow));
}
// 归并排序（迭代）
function sortList(head) {
  if (!head || !head.next) return head;
  const cut = (head, n) => {
    let p = head;
    while (--n && p) p = p.next;
    if (!p) return null;
    let suc = p.next;
    p.next = null;
    return suc;
  };
  const mergeTwoLists = (l1, l2) => {
    if (!l1) return l2;
    if (!l2) return l1;
    if (l1.val < l2.val) {
      l1.next = mergeTwoLists(l1.next, l2);
      return l1;
    } else {
      l2.next = mergeTwoLists(l1, l2.next);
      return l2;
    }
  };
  let [length, tmp] = [0, head];
  while (tmp) {
    length++;
    tmp = tmp.next;
  }
  // 第一次cut 1，然后根据归并的思路，cut的大小依次*2，边界条件位size<length，
  // 因为size==n表示的是链表的每个长度为n的段已经是有序的了，执行循环的目的就是把有序的长度为n的段连起来，
  // 因此当size>=length时，表示长度为size的段已经有序，即原链表已经归并完成，结束循环。只有当size<length时才表明没有归并完成，进入循环继续归并
  let dummy = { next: head };
  for (let size = 1; size < length; size *= 2) {
    // cur表示待分割链表的第一个，tail表示已经合并好的链表的最后一个
    let cur = dummy.next;
    let tail = dummy;
    while (cur) {
      let left = cur;
      let right = cut(left, size);
      cur = cut(right, size);
      tail.next = mergeTwoLists(left, right);
      while (tail.next) tail = tail.next;
    }
  }
  return dummy.next;
}
```