# 数据类型

Javascript 是一种动态语言， ECMAScript 标准定义了8种内建类型；

## 内建类型

- undefined
- null
- number
- boolean
- string
- symbol
- BigInt
- object

其中， `object` 被称为**引用类型**，其余的则被称为**原始类型**。

类似函数、数组、普通对象等都是一个 `object` 引用类型。 

---



## 特殊值

JavaScript 在各个类型中定义了一些特殊值。

### undefined

对于 `undefined` ，我们可以用 `void 0` 来进行替代，这在一些场景下是最优的操作，因为 `undefined` 与 `null` 不同，开发者可以在全局对`undefined` 进行覆盖。

```js
console.log(typeof void 0) // undefined
```

### NaN

`NaN` 是一种“哨兵值”（一个被赋予了特殊意义的普通的值），它代表 `number` 集合内的一种特殊的错误情况。

```js
console.log(typeof NaN) // number
```

`NaN`还存在一种诡异的现象，我不是我？？？

```js
console.log(NaN == NaN); // false
```

我们可以使用 ES6 提供的 `Number.isNaN()` 进行判断，也可以自己写一个：

```js
function isNaN(val) {
  return val !== val;
}
```

在 `Number` 类型中，还存在 `Infinity` 和 `-Infinity` 用于表示正负无穷。

---



## 值与引用

**对于原始类型来说，变量用栈存储，存储的是值本身，而对于引用类型，变量用堆存储，存储的是其在内存中的地址。**

```js
let o1,
  o2 = { key: "val" };
let s1 = (s2 = "str");
console.log(o1 === o2); // false
console.log(s1 === s2); // true
```

---

## 类型判断

对于除了 `null` 之外的原始类型，我们都可以使用 `typeof` 进行判断，

```js
console.log(typeof null); // object

console.log(typeof undefined); // undefined
console.log(typeof 123); // string
console.log(typeof true); // boolean
console.log(typeof "hello world"); // string
console.log(typeof Symbol()); // symbol
```

对于 `null` ，我们可以使用这种方式行判断：

```js
function isNull(val) {
  return !val && typeof val === "object";
}
```

对于引用类型，使用 `typeof` 只能够判断出 `function` 类型，其余的都是`object`。

```js
const func = () => {};
console.log(typeof func); // function
console.log(typeof { key: "val" }); // object
console.log(typeof [1, 2, 3]); // object
```

我们还可以使用 `Object.prototype.toString.call()` 来判断变量的类型。

```js
console.log(Object.prototype.toString.call(1)); // [object Number]
console.log(Object.prototype.toString.call([])); // [object Array]
console.log(Object.prototype.toString.call({})); // [object Object]
console.log(Object.prototype.toString.call(/hello world/)); // [object RegExp]
console.log(Object.prototype.toString.call(() => {})); // [object Function]
console.log(Object.prototype.toString.call(true)); // [object Boolean]
console.log(Object.prototype.toString.call(null)); // [object Null]
console.log(Object.prototype.toString.call(undefined)); // [object Undefined]
console.log(Object.prototype.toString.call(Error())); // [object Error]
console.log(Object.prototype.toString.call(Symbol())); // [object Symbol]
console.log(Object.prototype.toString.call(new Set())); // [object Set]
console.log(Object.prototype.toString.call(new Map())); // [object Map]
function* gen() {}
console.log(Object.prototype.toString.call(gen)); // [object GeneratorFunction]
```

 `Object.prototype.toString.call()` 访问的是变量的 `[[Class]]` ，因为引用类型在创建的时候，在内部有一个 `[[Class]]` 标签，用于标识创建该对象的原生构造函数，而对于原生类型，则存在一种**类型包装**的机制，在开发者使用字面量进行创建变量的时候，实际上是内部帮助我们使用原生构造函数进行创建的，所以我们可以在字面量上对原生方法进行调用。

 ## 参考

- [You-Dont-Know-JS / types & grammar](https://github.com/getify/You-Dont-Know-JS/tree/1ed-zh-CN/types%20%26%20grammar)