# 模块化

## 主要概念

- 模块标识符：模块系统本质上是一个键/值实体，每个模块都存在一个标识符用于模块的检索，在原生系统下，标识符可能是文件的实际路径，而在模拟的模块系统下，标识符是一个命名空间路径的字符串。
- 模块依赖：模块系统的核心是管理依赖，依赖指的是本地模块向模块系统声明的一组外部模块，依赖本质上也是模块，本地模块的正常运行需要这些外部依赖的正确加载。
- 模块加载：指依赖模块的初始化工作。
- 入口：模块的入口，代码执行的起点。
- 异步依赖：模块在需要的时候进行加载，加载完成后提供一组回调，即按需加载。
- 动态依赖：在程序执行过程由开发者中动态地添加依赖。
- 静态分析：在不执行代码的情况下推断其行为。
- 循环依赖：加载已经加载过的模块。

## 思想

模块化的思想在于把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码。

## 优势

- 提供命名空间，避免变量污染。
- 高复用性
- 高可维护性

## 发展历史

长期以来，JavaScript 都没有独立的模块体系，针对这个问题，社区提供了一些解决方案，主要有 CommonJS 和 AMD 两种，CommonJS 用于服务端，AMD 用于浏览器。

CommonJS 采用同步的方式加载模块，因为在服务端中，文件都存储在本地磁盘上，文件读取的速度非常快，不容易造成阻塞，而在浏览器端，模块的加载速度受限于网络，因此，AMD 采用了异步的加载方式，模块的加载不会阻塞代码的执行，所有依赖于外部模块的代码都会通过模块加载完成的回调函数进行执行。

直至 ES6 的出现，ES6 在语言标准层面实现了模块功能，其模块功能完全可以替代 CommonJS 和 AMD 两种方案成为通用的解决方案。

## CommonJS 和 ES6 模块之间的差异

此处主要参考[阮一峰老师的 ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs/module-loader)，再加上一些个人理解。

两者之间的差异主要有三点：

- 模块的输出不同
- 加载时机不同
- 加载方式不同

### 模块的输出不同

- CommonJS 模块输出的是一个值的拷贝。
- ES6 模块输出的是值的引用。

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。

例如：

```js
// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter: counter,
  incCounter: incCounter,
};

// main.js
var mod = require("./lib");

console.log(mod.counter); // 3
mod.incCounter();
console.log(mod.counter); // 3
```

在 `main.js` 文件中引入 `lib.js`，执行 `mod.incCounter()` 方法之后，`lib.js` 中 `counter` 的值实际上是已经改变了的，但是第二次打印输出的只是最开始引入模块时拷贝的值，而不是模块最新的状态。

而在 ES6 模块机制中，JavaScript 引擎对脚本静态分析的时候，遇到模块加载命令 import 时会生成一个只读引用，等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。换句话说，ES6 模块的 import 有点像 Unix 系统的“符号连接”，原始值变了，import 加载的值也会跟着变。因此，ES6 模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。

### 加载时机不同

CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

原因在于：

- CommonJS 加载的是一个对象（即 `module.exports` 属性），该对象在脚本运行完后才会生成，后续再从这个对象直接读取属性。
- ES6 模块加载的不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

### 加载方式不同

CommonJS 模块的 require() 是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段。

## 参考

- [ECMAScript 6 入门](https://es6.ruanyifeng.com/#docs/module-loader)
- [JavaScript 高级程序设计（第 4 版）](https://www.ituring.com.cn/book/2472)